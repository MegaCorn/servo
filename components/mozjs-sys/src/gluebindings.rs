/* automatically generated by rust-bindgen 0.71.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub use crate::glue::EncodedStringCallback;
    pub(crate) use crate::jsapi::*;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod _Has_ADL_swap_detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod pmr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod placeholders {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod _Ensure_adl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use crate::jsapi::mozilla::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use crate::jsapi::js::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
    }
    pub mod stdext {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub(crate) use crate::jsapi::JS::*;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod IPC {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type WantToMeasure =
        ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>;
    pub type GetSize =
        ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> usize>;
    extern "C" {
        #[link_name = "\u{1}?gWantToMeasure@@3P6A_NPEAVJSObject@@@ZEA"]
        pub static mut gWantToMeasure: root::WantToMeasure;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JobQueueTraps {
        pub getIncumbentGlobal: ::std::option::Option<
            unsafe extern "C" fn(
                queue: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject,
        >,
        pub enqueuePromiseJob: ::std::option::Option<
            unsafe extern "C" fn(
                queue: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                job: root::JS::HandleObject,
                allocationSite: root::JS::HandleObject,
                incumbentGlobal: root::JS::HandleObject,
            ) -> bool,
        >,
        pub empty: ::std::option::Option<
            unsafe extern "C" fn(queue: *const ::std::os::raw::c_void) -> bool,
        >,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JobQueueTraps"][::std::mem::size_of::<JobQueueTraps>() - 24usize];
        ["Alignment of JobQueueTraps"][::std::mem::align_of::<JobQueueTraps>() - 8usize];
        ["Offset of field: JobQueueTraps::getIncumbentGlobal"]
            [::std::mem::offset_of!(JobQueueTraps, getIncumbentGlobal) - 0usize];
        ["Offset of field: JobQueueTraps::enqueuePromiseJob"]
            [::std::mem::offset_of!(JobQueueTraps, enqueuePromiseJob) - 8usize];
        ["Offset of field: JobQueueTraps::empty"]
            [::std::mem::offset_of!(JobQueueTraps, empty) - 16usize];
    };
    #[repr(C)]
    pub struct RustJobQueue__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJobQueue {
        pub vtable_: *const RustJobQueue__bindgen_vtable,
        pub mTraps: root::JobQueueTraps,
        pub mQueue: *const ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of RustJobQueue"][::std::mem::size_of::<RustJobQueue>() - 40usize];
        ["Alignment of RustJobQueue"][::std::mem::align_of::<RustJobQueue>() - 8usize];
        ["Offset of field: RustJobQueue::mTraps"]
            [::std::mem::offset_of!(RustJobQueue, mTraps) - 8usize];
        ["Offset of field: RustJobQueue::mQueue"]
            [::std::mem::offset_of!(RustJobQueue, mQueue) - 32usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSExternalStringCallbacksTraps {
        pub latin1Finalize: ::std::option::Option<
            unsafe extern "C" fn(
                privateData: *const ::std::os::raw::c_void,
                chars: *mut root::JS::Latin1Char,
            ),
        >,
        pub utf16Finalize: ::std::option::Option<
            unsafe extern "C" fn(privateData: *const ::std::os::raw::c_void, chars: *mut u16),
        >,
        pub latin1SizeOfBuffer: ::std::option::Option<
            unsafe extern "C" fn(
                privateData: *const ::std::os::raw::c_void,
                chars: *const root::JS::Latin1Char,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize,
        >,
        pub utf16SizeOfBuffer: ::std::option::Option<
            unsafe extern "C" fn(
                privateData: *const ::std::os::raw::c_void,
                chars: *const u16,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize,
        >,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSExternalStringCallbacksTraps"]
            [::std::mem::size_of::<JSExternalStringCallbacksTraps>() - 32usize];
        ["Alignment of JSExternalStringCallbacksTraps"]
            [::std::mem::align_of::<JSExternalStringCallbacksTraps>() - 8usize];
        ["Offset of field: JSExternalStringCallbacksTraps::latin1Finalize"]
            [::std::mem::offset_of!(JSExternalStringCallbacksTraps, latin1Finalize) - 0usize];
        ["Offset of field: JSExternalStringCallbacksTraps::utf16Finalize"]
            [::std::mem::offset_of!(JSExternalStringCallbacksTraps, utf16Finalize) - 8usize];
        ["Offset of field: JSExternalStringCallbacksTraps::latin1SizeOfBuffer"]
            [::std::mem::offset_of!(JSExternalStringCallbacksTraps, latin1SizeOfBuffer) - 16usize];
        ["Offset of field: JSExternalStringCallbacksTraps::utf16SizeOfBuffer"]
            [::std::mem::offset_of!(JSExternalStringCallbacksTraps, utf16SizeOfBuffer) - 24usize];
    };
    #[repr(C)]
    pub struct RustJSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJSExternalStringCallbacks {
        pub vtable_: *const RustJSExternalStringCallbacks__bindgen_vtable,
        pub mTraps: root::JSExternalStringCallbacksTraps,
        pub privateData: *mut ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of RustJSExternalStringCallbacks"]
            [::std::mem::size_of::<RustJSExternalStringCallbacks>() - 48usize];
        ["Alignment of RustJSExternalStringCallbacks"]
            [::std::mem::align_of::<RustJSExternalStringCallbacks>() - 8usize];
        ["Offset of field: RustJSExternalStringCallbacks::mTraps"]
            [::std::mem::offset_of!(RustJSExternalStringCallbacks, mTraps) - 8usize];
        ["Offset of field: RustJSExternalStringCallbacks::privateData"]
            [::std::mem::offset_of!(RustJSExternalStringCallbacks, privateData) - 40usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProxyTraps {
        pub enter: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                action: root::js::BaseProxyHandler_Action,
                bp: *mut bool,
            ) -> bool,
        >,
        pub getOwnPropertyDescriptor: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool,
        >,
        pub defineProperty: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub ownPropertyKeys: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub delete_: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub enumerate: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub getPrototypeIfOrdinary: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isOrdinary: *mut bool,
                protop: root::JS::MutableHandleObject,
            ) -> bool,
        >,
        pub getPrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool,
        >,
        pub setPrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub setImmutablePrototype: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool,
        >,
        pub preventExtensions: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub isExtensible: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool,
        >,
        pub has: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool,
        >,
        pub get: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub set: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >,
        pub call: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool,
        >,
        pub construct: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool,
        >,
        pub hasOwn: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool,
        >,
        pub getOwnEnumerablePropertyKeys: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool,
        >,
        pub nativeCall: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                test: root::JS::IsAcceptableThis,
                impl_: root::JS::NativeImpl,
                args: root::JS::CallArgs,
            ) -> bool,
        >,
        pub objectClassIs: ::std::option::Option<
            unsafe extern "C" fn(
                obj: root::JS::HandleObject,
                classValue: root::js::ESClass,
                cx: *mut root::JSContext,
            ) -> bool,
        >,
        pub className: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char,
        >,
        pub fun_toString: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isToString: bool,
            ) -> *mut root::JSString,
        >,
        pub boxedValue_unbox: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub defaultValue: ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >,
        pub trace: ::std::option::Option<
            unsafe extern "C" fn(trc: *mut root::JSTracer, proxy: *mut root::JSObject),
        >,
        pub finalize: ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JS::GCContext, proxy: *mut root::JSObject),
        >,
        pub objectMoved: ::std::option::Option<
            unsafe extern "C" fn(proxy: *mut root::JSObject, old: *mut root::JSObject) -> usize,
        >,
        pub isCallable:
            ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>,
        pub isConstructor:
            ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of ProxyTraps"][::std::mem::size_of::<ProxyTraps>() - 240usize];
        ["Alignment of ProxyTraps"][::std::mem::align_of::<ProxyTraps>() - 8usize];
        ["Offset of field: ProxyTraps::enter"][::std::mem::offset_of!(ProxyTraps, enter) - 0usize];
        ["Offset of field: ProxyTraps::getOwnPropertyDescriptor"]
            [::std::mem::offset_of!(ProxyTraps, getOwnPropertyDescriptor) - 8usize];
        ["Offset of field: ProxyTraps::defineProperty"]
            [::std::mem::offset_of!(ProxyTraps, defineProperty) - 16usize];
        ["Offset of field: ProxyTraps::ownPropertyKeys"]
            [::std::mem::offset_of!(ProxyTraps, ownPropertyKeys) - 24usize];
        ["Offset of field: ProxyTraps::delete_"]
            [::std::mem::offset_of!(ProxyTraps, delete_) - 32usize];
        ["Offset of field: ProxyTraps::enumerate"]
            [::std::mem::offset_of!(ProxyTraps, enumerate) - 40usize];
        ["Offset of field: ProxyTraps::getPrototypeIfOrdinary"]
            [::std::mem::offset_of!(ProxyTraps, getPrototypeIfOrdinary) - 48usize];
        ["Offset of field: ProxyTraps::getPrototype"]
            [::std::mem::offset_of!(ProxyTraps, getPrototype) - 56usize];
        ["Offset of field: ProxyTraps::setPrototype"]
            [::std::mem::offset_of!(ProxyTraps, setPrototype) - 64usize];
        ["Offset of field: ProxyTraps::setImmutablePrototype"]
            [::std::mem::offset_of!(ProxyTraps, setImmutablePrototype) - 72usize];
        ["Offset of field: ProxyTraps::preventExtensions"]
            [::std::mem::offset_of!(ProxyTraps, preventExtensions) - 80usize];
        ["Offset of field: ProxyTraps::isExtensible"]
            [::std::mem::offset_of!(ProxyTraps, isExtensible) - 88usize];
        ["Offset of field: ProxyTraps::has"][::std::mem::offset_of!(ProxyTraps, has) - 96usize];
        ["Offset of field: ProxyTraps::get"][::std::mem::offset_of!(ProxyTraps, get) - 104usize];
        ["Offset of field: ProxyTraps::set"][::std::mem::offset_of!(ProxyTraps, set) - 112usize];
        ["Offset of field: ProxyTraps::call"][::std::mem::offset_of!(ProxyTraps, call) - 120usize];
        ["Offset of field: ProxyTraps::construct"]
            [::std::mem::offset_of!(ProxyTraps, construct) - 128usize];
        ["Offset of field: ProxyTraps::hasOwn"]
            [::std::mem::offset_of!(ProxyTraps, hasOwn) - 136usize];
        ["Offset of field: ProxyTraps::getOwnEnumerablePropertyKeys"]
            [::std::mem::offset_of!(ProxyTraps, getOwnEnumerablePropertyKeys) - 144usize];
        ["Offset of field: ProxyTraps::nativeCall"]
            [::std::mem::offset_of!(ProxyTraps, nativeCall) - 152usize];
        ["Offset of field: ProxyTraps::objectClassIs"]
            [::std::mem::offset_of!(ProxyTraps, objectClassIs) - 160usize];
        ["Offset of field: ProxyTraps::className"]
            [::std::mem::offset_of!(ProxyTraps, className) - 168usize];
        ["Offset of field: ProxyTraps::fun_toString"]
            [::std::mem::offset_of!(ProxyTraps, fun_toString) - 176usize];
        ["Offset of field: ProxyTraps::boxedValue_unbox"]
            [::std::mem::offset_of!(ProxyTraps, boxedValue_unbox) - 184usize];
        ["Offset of field: ProxyTraps::defaultValue"]
            [::std::mem::offset_of!(ProxyTraps, defaultValue) - 192usize];
        ["Offset of field: ProxyTraps::trace"]
            [::std::mem::offset_of!(ProxyTraps, trace) - 200usize];
        ["Offset of field: ProxyTraps::finalize"]
            [::std::mem::offset_of!(ProxyTraps, finalize) - 208usize];
        ["Offset of field: ProxyTraps::objectMoved"]
            [::std::mem::offset_of!(ProxyTraps, objectMoved) - 216usize];
        ["Offset of field: ProxyTraps::isCallable"]
            [::std::mem::offset_of!(ProxyTraps, isCallable) - 224usize];
        ["Offset of field: ProxyTraps::isConstructor"]
            [::std::mem::offset_of!(ProxyTraps, isConstructor) - 232usize];
    };
    extern "C" {
        pub static mut HandlerFamily: ::std::os::raw::c_int;
    }
    #[repr(C)]
    pub struct WrapperProxyHandler__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct WrapperProxyHandler {
        pub vtable_: *const WrapperProxyHandler__bindgen_vtable,
        pub __bindgen_padding_0: [u64; 2usize],
        pub mTraps: root::ProxyTraps,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of WrapperProxyHandler"][::std::mem::size_of::<WrapperProxyHandler>() - 264usize];
        ["Alignment of WrapperProxyHandler"]
            [::std::mem::align_of::<WrapperProxyHandler>() - 8usize];
        ["Offset of field: WrapperProxyHandler::mTraps"]
            [::std::mem::offset_of!(WrapperProxyHandler, mTraps) - 24usize];
    };
    #[repr(C)]
    pub struct ForwardingProxyHandler__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct ForwardingProxyHandler {
        pub vtable_: *const ForwardingProxyHandler__bindgen_vtable,
        pub __bindgen_padding_0: [u64; 2usize],
        pub mTraps: root::ProxyTraps,
        pub mExtra: *const ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of ForwardingProxyHandler"]
            [::std::mem::size_of::<ForwardingProxyHandler>() - 272usize];
        ["Alignment of ForwardingProxyHandler"]
            [::std::mem::align_of::<ForwardingProxyHandler>() - 8usize];
        ["Offset of field: ForwardingProxyHandler::mTraps"]
            [::std::mem::offset_of!(ForwardingProxyHandler, mTraps) - 24usize];
        ["Offset of field: ForwardingProxyHandler::mExtra"]
            [::std::mem::offset_of!(ForwardingProxyHandler, mExtra) - 264usize];
    };
    #[repr(C)]
    pub struct ServoDOMVisitor__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct ServoDOMVisitor {
        pub vtable_: *const ServoDOMVisitor__bindgen_vtable,
        pub __bindgen_padding_0: u64,
        pub get_size: root::GetSize,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of ServoDOMVisitor"][::std::mem::size_of::<ServoDOMVisitor>() - 24usize];
        ["Alignment of ServoDOMVisitor"][::std::mem::align_of::<ServoDOMVisitor>() - 8usize];
        ["Offset of field: ServoDOMVisitor::get_size"]
            [::std::mem::offset_of!(ServoDOMVisitor, get_size) - 16usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPrincipalsCallbacks {
        pub write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSPrincipals,
                cx: *mut root::JSContext,
                writer: *mut root::JSStructuredCloneWriter,
            ) -> bool,
        >,
        pub isSystemOrAddonPrincipal:
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSPrincipals) -> bool>,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPrincipalsCallbacks"][::std::mem::size_of::<JSPrincipalsCallbacks>() - 16usize];
        ["Alignment of JSPrincipalsCallbacks"]
            [::std::mem::align_of::<JSPrincipalsCallbacks>() - 8usize];
        ["Offset of field: JSPrincipalsCallbacks::write"]
            [::std::mem::offset_of!(JSPrincipalsCallbacks, write) - 0usize];
        ["Offset of field: JSPrincipalsCallbacks::isSystemOrAddonPrincipal"]
            [::std::mem::offset_of!(JSPrincipalsCallbacks, isSystemOrAddonPrincipal) - 8usize];
    };
    #[repr(C)]
    pub struct RustJSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    pub struct RustJSPrincipals {
        pub vtable_: *const RustJSPrincipals__bindgen_vtable,
        pub __bindgen_padding_0: u64,
        pub callbacks: root::JSPrincipalsCallbacks,
        pub privateData: *mut ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of RustJSPrincipals"][::std::mem::size_of::<RustJSPrincipals>() - 40usize];
        ["Alignment of RustJSPrincipals"][::std::mem::align_of::<RustJSPrincipals>() - 8usize];
        ["Offset of field: RustJSPrincipals::callbacks"]
            [::std::mem::offset_of!(RustJSPrincipals, callbacks) - 16usize];
        ["Offset of field: RustJSPrincipals::privateData"]
            [::std::mem::offset_of!(RustJSPrincipals, privateData) - 32usize];
    };
        pub fn ShouldMeasureObject(
            obj: *mut root::JSObject,
            iface: *mut *mut root::nsISupports,
        ) -> bool { println!("ShouldMeasureObject called"); true }
        pub fn CreateRustJSPrincipals(
            callbacks: *const root::JSPrincipalsCallbacks,
            privateData: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSPrincipals { println!("CreateRustJSPrincipals called"); ::std::ptr::null_mut() }
        pub fn DestroyRustJSPrincipals(principals: *mut root::JSPrincipals) { println!("DestroyRustJSPrincipals called");}
        pub fn GetRustJSPrincipalsPrivate(
            principals: *mut root::JSPrincipals,
        ) -> *mut ::std::os::raw::c_void { println!("GetRustJSPrincipalsPrivate called"); ::std::ptr::null_mut() }
        pub fn InvokeGetOwnPropertyDescriptor(
            handler: *const ::std::os::raw::c_void,
            cx: *mut root::JSContext,
            proxy: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            isNone: *mut bool,
        ) -> bool { println!("InvokeGetOwnPropertyDescriptor called"); true }
        pub fn InvokeHasOwn(
            handler: *const ::std::os::raw::c_void,
            cx: *mut root::JSContext,
            proxy: root::JS::HandleObject,
            id: root::JS::HandleId,
            bp: *mut bool,
        ) -> bool { println!("InvokeHasOwn called"); true }
        pub fn RUST_FUNCTION_VALUE_TO_JITINFO(v: root::JS::Value) -> *const root::JSJitInfo { println!("RUST_FUNCTION_VALUE_TO_JITINFO called"); ::std::ptr::null_mut() }
        pub fn CallJitGetterOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool { println!("CallJitGetterOp called"); true }
        pub fn CallJitSetterOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool { println!("CallJitSetterOp called"); true }
        pub fn CallJitMethodOp(
            info: *const root::JSJitInfo,
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            argc: u32,
            vp: *mut root::JS::Value,
        ) -> bool { println!("CallJitMethodOp called"); true }
        pub fn CreateProxyHandler(
            aTraps: *const root::ProxyTraps,
            aExtra: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void { println!("CreateProxyHandler called"); ::std::ptr::null_mut() }
        pub fn CreateWrapperProxyHandler(
            aTraps: *const root::ProxyTraps,
        ) -> *const ::std::os::raw::c_void { println!("CreateWrapperProxyHandler called"); ::std::ptr::null_mut() }
        pub fn DeleteWrapperProxyHandler(handler: *const ::std::os::raw::c_void) { println!("DeleteWrapperProxyHandler called");}
        pub fn GetCrossCompartmentWrapper() -> *const ::std::os::raw::c_void { println!("GetCrossCompartmentWrapper called"); ::std::ptr::null_mut() }
        pub fn GetSecurityWrapper() -> *const ::std::os::raw::c_void { println!("GetSecurityWrapper called"); ::std::ptr::null_mut() }
        pub fn DeleteCompileOptions(aOpts: *mut root::JS::ReadOnlyCompileOptions) { println!("DeleteCompileOptions called");}
        pub fn NewCompileOptions(
            aCx: *mut root::JSContext,
            aFile: *const ::std::os::raw::c_char,
            aLine: ::std::os::raw::c_uint,
        ) -> *mut root::JS::ReadOnlyCompileOptions { println!("NewCompileOptions called"); ::std::ptr::null_mut() }
        pub fn NewProxyObject(
            aCx: *mut root::JSContext,
            aHandler: *const ::std::os::raw::c_void,
            aPriv: root::JS::HandleValue,
            proto: *mut root::JSObject,
            aClass: *const root::JSClass,
            aLazyProto: bool,
        ) -> *mut root::JSObject { println!("NewProxyObject called"); ::std::ptr::null_mut() }
        pub fn WrapperNew(
            aCx: *mut root::JSContext,
            aObj: root::JS::HandleObject,
            aHandler: *const ::std::os::raw::c_void,
            aClass: *const root::JSClass,
        ) -> *mut root::JSObject { println!("WrapperNew called"); ::std::ptr::null_mut() }
        pub fn GetWindowProxyClass() -> *const root::JSClass { println!("GetWindowProxyClass called"); ::std::ptr::null_mut() }
        pub fn NewWindowProxy(
            aCx: *mut root::JSContext,
            aObj: root::JS::HandleObject,
            aHandler: *const ::std::os::raw::c_void,
        ) -> *mut root::JSObject { println!("NewWindowProxy called"); ::std::ptr::null_mut() }
        pub fn GetProxyReservedSlot(
            obj: *mut root::JSObject,
            slot: u32,
            dest: *mut root::JS::Value,
        ) { println!("GetProxyReservedSlot called");}
        pub fn GetProxyPrivate(obj: *mut root::JSObject, dest: *mut root::JS::Value) { println!("GetProxyPrivate called");}
        pub fn SetProxyReservedSlot(
            obj: *mut root::JSObject,
            slot: u32,
            val: *const root::JS::Value,
        ) { println!("SetProxyReservedSlot called");}
        pub fn SetProxyPrivate(obj: *mut root::JSObject, expando: *const root::JS::Value) { println!("SetProxyPrivate called");}
        pub fn RUST_JSID_IS_INT(id: root::JS::HandleId) -> bool { println!("RUST_JSID_IS_INT called"); true }
        pub fn int_to_jsid(i: i32, id: root::JS::MutableHandleId) { println!("int_to_jsid called");}
        pub fn RUST_JSID_TO_INT(id: root::JS::HandleId) -> i32 { println!("RUST_JSID_TO_INT called"); 0 }
        pub fn RUST_JSID_IS_STRING(id: root::JS::HandleId) -> bool { println!("RUST_JSID_IS_STRING called"); true }
        pub fn RUST_JSID_TO_STRING(id: root::JS::HandleId) -> *mut root::JSString { println!("RUST_JSID_TO_STRING called"); ::std::ptr::null_mut() }
        pub fn RUST_SYMBOL_TO_JSID(sym: *mut root::JS::Symbol, id: root::JS::MutableHandleId) { println!("RUST_SYMBOL_TO_JSID called");}
        pub fn RUST_JSID_IS_VOID(id: root::JS::HandleId) -> bool { println!("RUST_JSID_IS_VOID called"); true }
        pub fn SetBuildId(
            buildId: *mut root::JS::BuildIdCharVector,
            chars: *const ::std::os::raw::c_char,
            len: usize,
        ) -> bool { println!("SetBuildId called"); true }
        pub fn RUST_SET_JITINFO(func: *mut root::JSFunction, info: *const root::JSJitInfo) { println!("RUST_SET_JITINFO called");}
        pub fn RUST_INTERNED_STRING_TO_JSID(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            id: root::JS::MutableHandleId,
        ) { println!("RUST_INTERNED_STRING_TO_JSID called");}
        pub fn RUST_js_GetErrorMessage(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: u32,
        ) -> *const root::JSErrorFormatString { println!("RUST_js_GetErrorMessage called"); ::std::ptr::null_mut() }
        pub fn IsProxyHandlerFamily(obj: *mut root::JSObject) -> bool { println!("IsProxyHandlerFamily called"); true }
        pub fn GetProxyHandlerFamily() -> *const ::std::os::raw::c_void { println!("GetProxyHandlerFamily called"); ::std::ptr::null_mut() }
        pub fn GetProxyHandlerExtra(obj: *mut root::JSObject) -> *const ::std::os::raw::c_void { println!("GetProxyHandlerExtra called"); ::std::ptr::null_mut() }
        pub fn GetProxyHandler(obj: *mut root::JSObject) -> *const ::std::os::raw::c_void { println!("GetProxyHandler called"); ::std::ptr::null_mut() }
        pub fn ReportErrorASCII(aCx: *mut root::JSContext, aError: *const ::std::os::raw::c_char) { println!("ReportErrorASCII called");}
        pub fn ReportErrorUTF8(aCx: *mut root::JSContext, aError: *const ::std::os::raw::c_char) { println!("ReportErrorUTF8 called");}
        pub fn IsWrapper(obj: *mut root::JSObject) -> bool { println!("IsWrapper called"); true }
        pub fn UnwrapObjectStatic(obj: *mut root::JSObject) -> *mut root::JSObject { println!("UnwrapObjectStatic called"); ::std::ptr::null_mut() }
        pub fn UnwrapObjectDynamic(
            obj: *mut root::JSObject,
            cx: *mut root::JSContext,
            stopAtWindowProxy: bool,
        ) -> *mut root::JSObject { println!("UnwrapObjectDynamic called"); ::std::ptr::null_mut() }
        pub fn UncheckedUnwrapObject(
            obj: *mut root::JSObject,
            stopAtWindowProxy: bool,
        ) -> *mut root::JSObject { println!("UncheckedUnwrapObject called"); ::std::ptr::null_mut() }
        pub fn CreateRootedIdVector(
            cx: *mut root::JSContext,
        ) -> *mut root::JS::PersistentRootedIdVector { println!("CreateRootedIdVector called"); ::std::ptr::null_mut() }
        pub fn GetIdVectorAddress(
            v: *mut root::JS::PersistentRootedIdVector,
        ) -> *mut ::std::os::raw::c_void { println!("GetIdVectorAddress called"); ::std::ptr::null_mut() }
        pub fn SliceRootedIdVector(
            v: *const root::JS::PersistentRootedIdVector,
            length: *mut usize,
        ) -> *const root::jsid { println!("SliceRootedIdVector called"); ::std::ptr::null_mut() }
        pub fn AppendToIdVector(v: root::JS::MutableHandleIdVector, id: root::JS::HandleId)
            -> bool { println!("AppendToIdVector called"); true }
        pub fn DestroyRootedIdVector(v: *mut root::JS::PersistentRootedIdVector) { println!("DestroyRootedIdVector called");}
        pub fn CreateRootedObjectVector(
            aCx: *mut root::JSContext,
        ) -> *mut root::JS::PersistentRootedObjectVector { println!("CreateRootedObjectVector called"); ::std::ptr::null_mut() }
        pub fn GetObjectVectorAddress(
            v: *mut root::JS::PersistentRootedObjectVector,
        ) -> *mut ::std::os::raw::c_void { println!("GetObjectVectorAddress called"); ::std::ptr::null_mut() }
        pub fn AppendToRootedObjectVector(
            v: *mut root::JS::PersistentRootedObjectVector,
            obj: *mut root::JSObject,
        ) -> bool { println!("AppendToRootedObjectVector called"); true }
        pub fn DeleteRootedObjectVector(v: *mut root::JS::PersistentRootedObjectVector) { println!("DeleteRootedObjectVector called");}
        pub fn CollectServoSizes(
            cx: *mut root::JSContext,
            sizes: *mut root::JS::ServoSizes,
            gs: root::GetSize,
        ) -> bool { println!("CollectServoSizes called"); true }
        pub fn InitializeMemoryReporter(wtm: root::WantToMeasure) { println!("InitializeMemoryReporter called");}
        pub fn CallValueTracer(
            trc: *mut root::JSTracer,
            valuep: *mut root::JS::Heap<root::JS::Value>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallValueTracer called");}
        pub fn CallIdTracer(
            trc: *mut root::JSTracer,
            idp: *mut root::JS::Heap<root::jsid>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallIdTracer called");}
        pub fn CallObjectTracer(
            trc: *mut root::JSTracer,
            objp: *mut root::JS::Heap<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallObjectTracer called");}
        pub fn CallStringTracer(
            trc: *mut root::JSTracer,
            strp: *mut root::JS::Heap<*mut root::JSString>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallStringTracer called");}
        pub fn CallSymbolTracer(
            trc: *mut root::JSTracer,
            bip: *mut root::JS::Heap<*mut root::JS::Symbol>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallSymbolTracer called");}
        pub fn CallBigIntTracer(
            trc: *mut root::JSTracer,
            bip: *mut root::JS::Heap<*mut root::JS::BigInt>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallBigIntTracer called");}
        pub fn CallScriptTracer(
            trc: *mut root::JSTracer,
            scriptp: *mut root::JS::Heap<*mut root::JSScript>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallScriptTracer called");}
        pub fn CallFunctionTracer(
            trc: *mut root::JSTracer,
            funp: *mut root::JS::Heap<*mut root::JSFunction>,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallFunctionTracer called");}
        pub fn CallUnbarrieredObjectTracer(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallUnbarrieredObjectTracer called");}
        pub fn CallObjectRootTracer(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallObjectRootTracer called");}
        pub fn CallValueRootTracer(
            trc: *mut root::JSTracer,
            valp: *mut root::JS::Value,
            name: *const ::std::os::raw::c_char,
        ) { println!("CallValueRootTracer called");}
        pub fn CallPropertyDescriptorTracer(
            trc: *mut root::JSTracer,
            desc: *mut root::JS::PropertyDescriptor,
        ) { println!("CallPropertyDescriptorTracer called");}
        pub fn IsDebugBuild() -> bool { println!("IsDebugBuild called"); true }
        pub fn GetInt8ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        ) { println!("GetInt8ArrayLengthAndData called");}
        pub fn GetUint8ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) { println!("GetUint8ArrayLengthAndData called");}
        pub fn GetUint8ClampedArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) { println!("GetUint8ClampedArrayLengthAndData called");}
        pub fn GetInt16ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        ) { println!("GetInt16ArrayLengthAndData called");}
        pub fn GetUint16ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) { println!("GetUint16ArrayLengthAndData called");}
        pub fn GetInt32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        ) { println!("GetInt32ArrayLengthAndData called");}
        pub fn GetUint32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        ) { println!("GetUint32ArrayLengthAndData called");}
        pub fn GetFloat32ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        ) { println!("GetFloat32ArrayLengthAndData called");}
        pub fn GetFloat64ArrayLengthAndData(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        ) { println!("GetFloat64ArrayLengthAndData called");}
        pub fn NewJSAutoStructuredCloneBuffer(
            scope: root::JS::StructuredCloneScope,
            callbacks: *const root::JSStructuredCloneCallbacks,
        ) -> *mut root::JSAutoStructuredCloneBuffer { println!("NewJSAutoStructuredCloneBuffer called"); ::std::ptr::null_mut() }
        pub fn DeleteJSAutoStructuredCloneBuffer(buf: *mut root::JSAutoStructuredCloneBuffer) { println!("DeleteJSAutoStructuredCloneBuffer called");}
        pub fn GetLengthOfJSStructuredCloneData(data: *mut root::JSStructuredCloneData) -> usize { println!("GetLengthOfJSStructuredCloneData called"); 0 }
        pub fn CopyJSStructuredCloneData(src: *mut root::JSStructuredCloneData, dest: *mut u8) { println!("CopyJSStructuredCloneData called");}
        pub fn WriteBytesToJSStructuredCloneData(
            src: *const u8,
            len: usize,
            dest: *mut root::JSStructuredCloneData,
        ) -> bool { println!("WriteBytesToJSStructuredCloneData called"); true }
        pub fn JS_GetPromiseResult(
            promise: root::JS::HandleObject,
            dest: root::JS::MutableHandleValue,
        ) { println!("JS_GetPromiseResult called");}
        pub fn JS_GetScriptPrivate(script: *mut root::JSScript, dest: root::JS::MutableHandleValue) { println!("JS_GetScriptPrivate called");}
        pub fn JS_GetModulePrivate(module: *mut root::JSObject, dest: root::JS::MutableHandleValue) { println!("JS_GetModulePrivate called");}
        pub fn JS_GetScriptedCallerPrivate(
            cx: *mut root::JSContext,
            dest: root::JS::MutableHandleValue,
        ) { println!("JS_GetScriptedCallerPrivate called");}
        pub fn JS_GetNaNValue(cx: *mut root::JSContext, dest: *mut root::JS::Value) { println!("JS_GetNaNValue called");}
        pub fn JS_GetPositiveInfinityValue(cx: *mut root::JSContext, dest: *mut root::JS::Value) { println!("JS_GetPositiveInfinityValue called");}
        pub fn JS_GetEmptyStringValue(cx: *mut root::JSContext, dest: *mut root::JS::Value) { println!("JS_GetEmptyStringValue called");}
        pub fn JS_GetReservedSlot(obj: *mut root::JSObject, index: u32, dest: *mut root::JS::Value) { println!("JS_GetReservedSlot called");}
        pub fn JS_GetRegExpFlags(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            flags: *mut root::JS::RegExpFlags,
        ) { println!("JS_GetRegExpFlags called");}
        pub fn EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str_: root::JS::HandleString,
            cb: root::EncodedStringCallback,
        ) { println!("EncodeStringToUTF8 called");}
        pub fn JS_ForgetStringLinearness(str_: *mut root::JSLinearString) -> *mut root::JSString { println!("JS_ForgetStringLinearness called"); ::std::ptr::null_mut() }
        pub fn CreateJobQueue(
            aTraps: *const root::JobQueueTraps,
            aQueue: *const ::std::os::raw::c_void,
        ) -> *mut root::JS::JobQueue { println!("CreateJobQueue called"); ::std::ptr::null_mut() }
        pub fn DeleteJobQueue(queue: *mut root::JS::JobQueue) { println!("DeleteJobQueue called");}
        pub fn CreateJSExternalStringCallbacks(
            aTraps: *const root::JSExternalStringCallbacksTraps,
            privateData: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSExternalStringCallbacks { println!("CreateJSExternalStringCallbacks called"); ::std::ptr::null_mut() }
        pub fn DeleteJSExternalStringCallbacks(callbacks: *mut root::JSExternalStringCallbacks) { println!("DeleteJSExternalStringCallbacks called");}
        pub fn DispatchableRun(
            cx: *mut root::JSContext,
            ptr: *mut root::JS::Dispatchable,
            mb: root::JS::Dispatchable_MaybeShuttingDown,
        ) { println!("DispatchableRun called");}
        pub fn StreamConsumerConsumeChunk(
            sc: *mut root::JS::StreamConsumer,
            begin: *const u8,
            length: usize,
        ) -> bool { println!("StreamConsumerConsumeChunk called"); true }
        pub fn StreamConsumerStreamEnd(sc: *mut root::JS::StreamConsumer) { println!("StreamConsumerStreamEnd called");}
        pub fn StreamConsumerStreamError(sc: *mut root::JS::StreamConsumer, errorCode: usize) { println!("StreamConsumerStreamError called");}
        pub fn StreamConsumerNoteResponseURLs(
            sc: *mut root::JS::StreamConsumer,
            maybeUrl: *const ::std::os::raw::c_char,
            maybeSourceMapUrl: *const ::std::os::raw::c_char,
        ) { println!("StreamConsumerNoteResponseURLs called");}
        pub fn DescribeScriptedCaller(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            buflen: usize,
            line: *mut u32,
            col: *mut u32,
        ) -> bool { println!("DescribeScriptedCaller called"); true }
        pub fn SetDataPropertyDescriptor(
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            value: root::JS::HandleValue,
            attrs: u32,
        ) { println!("SetDataPropertyDescriptor called");}
        pub fn SetAccessorPropertyDescriptor(
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: u32,
        ) { println!("SetAccessorPropertyDescriptor called");}
        pub fn DumpJSStack(
            cx: *mut root::JSContext,
            showArgs: bool,
            showLocals: bool,
            showThisProps: bool,
        ) { println!("DumpJSStack called");}
}
